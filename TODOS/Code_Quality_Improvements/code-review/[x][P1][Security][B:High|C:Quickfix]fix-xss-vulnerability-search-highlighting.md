# Fix XSS Vulnerability in Search Highlighting

## Priority: P1 | Type: Security | Benefit: High | Complexity: Quickfix

## Problem Description

The search highlighting functionality in `OverlayWindow.qml` contains a cross-site scripting (XSS) vulnerability. While the code includes HTML escaping, there's a logical flaw in the regex replacement logic that could allow HTML injection if a search term contains carefully crafted HTML sequences.

**Security Risk**:
- Malicious search terms could inject arbitrary HTML/JavaScript
- Risk of code execution in QML Text.RichText context
- Potential for UI manipulation or data exposure
- Bypasses existing HTML escaping protections

**Root Cause**:
The regex replacement uses `$1` which refers to the original matched text from the escaped content, not the escaped search term, potentially reintroducing unescaped content.

## Implementation Plan

1. **Locate the vulnerable highlighting function** in `OverlayWindow.qml`
2. **Identify the problematic regex replacement** using `$1` backreference
3. **Replace `$1` with the escaped search term directly**
4. **Test with malicious input** to verify the fix prevents HTML injection
5. **Verify normal highlighting still works** with legitimate search terms

## File Locations

- `/home/jc/Dev/snippet-manager/ui/OverlayWindow.qml` (lines 370-413)
  - `highlightSearchTerm()` function implementation
  - Specifically the `replace()` call with HTML span injection

## Success Criteria

- Search terms containing HTML tags are properly escaped in highlights
- Normal search highlighting continues to work with legitimate terms
- No HTML injection possible through search input
- Visual highlighting maintains current styling and functionality
- No performance degradation in search operations

## Dependencies

None - This is a standalone security fix.

## Code Examples

**Current Implementation (Vulnerable)**:
```javascript
function highlightSearchTerm(text, searchTerm) {
    if (!searchTerm || searchTerm.length === 0) return escapeHtml(text)
    
    try {
        const escapedText = escapeHtml(text)
        const escapedTerm = escapeHtml(searchTerm)
        const regexPattern = escapedTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        const regex = new RegExp(`(${regexPattern})`, 'gi')
        
        // ❌ VULNERABLE: $1 refers to original matched text, not escaped term
        return escapedText.replace(regex, `<span style="color: ${Constants.search.matchHighlightTextColor};">$1</span>`)
    } catch (error) {
        window.debugLog("⚠️ Error in highlightSearchTerm: " + error.message)
        return escapeHtml(text)
    }
}
```

**Fixed Implementation**:
```javascript
function highlightSearchTerm(text, searchTerm) {
    if (!searchTerm || searchTerm.length === 0) return escapeHtml(text)
    
    try {
        const escapedText = escapeHtml(text)
        const escapedTerm = escapeHtml(searchTerm)
        const regexPattern = escapedTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        const regex = new RegExp(`(${regexPattern})`, 'gi')
        
        // ✅ SECURE: Use escaped term directly instead of backreference
        return escapedText.replace(regex, `<span style="color: ${Constants.search.matchHighlightTextColor};">${escapedTerm}</span>`)
    } catch (error) {
        window.debugLog("⚠️ Error in highlightSearchTerm: " + error.message)
        return escapeHtml(text)
    }
}
```

**Test Cases for Verification**:
```javascript
// Test malicious input (should be safely escaped)
highlightSearchTerm("Hello world", "<script>alert('xss')</script>")
// Should return: Hello world (no highlighting, no script execution)

// Test legitimate search (should highlight normally)  
highlightSearchTerm("Hello world", "world")
// Should return: Hello <span style="color: #00ff00;">world</span>
```

## Reminder

When implementation is finished, update the filename prefix from `[ ]` to `[x]`.